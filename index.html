<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Калькулятор темпа</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Telegram Games API -->
  <script src="https://telegram.org/js/games.js"></script>
  <style>
    /* ... ВЕСЬ ТВОЙ CSS БЕЗ ИЗМЕНЕНИЙ ... */
  </style>
</head>
<body>
  <!-- ... ВЕСЬ ТВОЙ HTML БЕЗ ИЗМЕНЕНИЙ ... -->

  <script>
    // === URL backend'а, который принимает результат ===
    const BACKEND_URL = "https://pacecalculator-chernaletski.amvera.io/pace-result";

    // Получаем query-параметры из URL: ?chat_id=...&message_id=...&user_id=...
    function getQueryParams() {
      const params = {};
      const query = window.location.search.substring(1);
      if (!query) return params;
      for (const part of query.split("&")) {
        const [key, value] = part.split("=");
        if (!key) continue;
        params[decodeURIComponent(key)] = value ? decodeURIComponent(value) : "";
      }
      return params;
    }

    const tgContext = getQueryParams();
    console.log("Telegram context:", tgContext);

    // Закрытие WebView / игры внутри Telegram
    function closeGameWebView() {
      try {
        if (window.TelegramGameProxy && typeof TelegramGameProxy.close === "function") {
          TelegramGameProxy.close(); // для игр
          return;
        }
        if (window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.close === "function") {
          Telegram.WebApp.close(); // для Mini Apps
          return;
        }
        console.log("Not inside Telegram, webview close skipped");
      } catch (e) {
        console.error("Failed to close webview", e);
      }
    }

    let isUpdating = false;
    let lastEdited = null; // 'D' | 'T' | 'P100' | 'PKM' | 'V'

    const el = {
      distance: document.getElementById("distance"),
      hours: document.getElementById("hours"),
      minutes: document.getElementById("minutes"),
      seconds: document.getElementById("seconds"),
      p100_min: document.getElementById("p100_min"),
      p100_sec: document.getElementById("p100_sec"),
      pkm_min: document.getElementById("pkm_min"),
      pkm_sec: document.getElementById("pkm_sec"),
      speed: document.getElementById("speed"),
      msg: document.getElementById("msg"),
      done: document.getElementById("done"),
      clear: document.getElementById("clear"),
    };

    const num = (v) => {
      if (v === "" || v === null || v === undefined) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    function sanitizeIntInput(input, min, max) {
      let v = input.value.trim();
      v = v.replace(/[^\d]/g, "");
      if (v === "") {
        input.value = "";
        return null;
      }
      let n = parseInt(v, 10);
      if (!Number.isFinite(n)) {
        input.value = "";
        return null;
      }
      if (min !== undefined && n < min) n = min;
      if (max !== undefined && n > max) n = max;
      input.value = String(n);
      return n;
    }

    function sanitizeDecimalInput(input, min) {
      let v = input.value.trim();
      if (!v) {
        input.value = "";
        return null;
      }
      v = v.replace(",", ".");
      const parts = v.split(".");
      if (parts.length > 2) {
        v = parts[0] + "." + parts.slice(1).join("");
      }
      v = v.replace(/[^0-9.]/g, "");
      input.value = v;
      const n = parseFloat(v);
      if (!Number.isFinite(n)) return null;
      if (min !== undefined && n < min) return null;
      return n;
    }

    function readState() {
      const D = sanitizeDecimalInput(el.distance, 0);

      const hhRaw = sanitizeIntInput(el.hours, 0, 999);
      const mmRaw = sanitizeIntInput(el.minutes, 0, 59);
      const ssRaw = sanitizeIntInput(el.seconds, 0, 59);
      const hasAnyTime = hhRaw !== null || mmRaw !== null || ssRaw !== null;
      const hh = hhRaw ?? 0;
      const mm = mmRaw ?? 0;
      const ss = ssRaw ?? 0;
      const Tsec = hasAnyTime ? hh * 3600 + mm * 60 + ss : null;

      const p100mRaw = sanitizeIntInput(el.p100_min, 0, 59);
      const p100sRaw = sanitizeIntInput(el.p100_sec, 0, 59);
      const hasP100 = p100mRaw !== null || p100sRaw !== null;
      const p100m = p100mRaw ?? 0;
      const p100s = p100sRaw ?? 0;
      const P100 = hasP100 ? p100m * 60 + p100s : null;

      const pkmMRaw = sanitizeIntInput(el.pkm_min, 0, 59);
      const pkmSRaw = sanitizeIntInput(el.pkm_sec, 0, 59);
      const hasPKM = pkmMRaw !== null || pkmSRaw !== null;
      const pkmM = pkmMRaw ?? 0;
      const pkmS = pkmSRaw ?? 0;
      const PKM = hasPKM ? pkmM * 60 + pkmS : null;

      const V = sanitizeDecimalInput(el.speed, 0);

      return {
        D,
        Tsec,
        P100,
        PKM,
        V,
        hasD: D !== null,
        hasT: Tsec !== null,
        hasP100,
        hasPKM,
        hasV: V !== null,
      };
    }

    // ... ВСЕ ФУНКЦИИ compute(), setDistance(), setTime() и т.д. БЕЗ ИЗМЕНЕНИЙ ...

    el.clear.addEventListener("click", () => {
      isUpdating = true;
      [
        el.distance,
        el.hours,
        el.minutes,
        el.seconds,
        el.p100_min,
        el.p100_sec,
        el.pkm_min,
        el.pkm_sec,
        el.speed,
      ].forEach((inp) => (inp.value = ""));
      lastEdited = null;
      isUpdating = false;
      showMsg("");
    });

    // Кнопка "Готово" — отправка результата на backend и закрытие WebView
    el.done.addEventListener("click", async () => {
      const s = readState();
      const count = ["hasD", "hasT", "hasP100", "hasPKM", "hasV"].reduce(
        (acc, k) => acc + (s[k] ? 1 : 0),
        0
      );
      if (count < 2) {
        alert("Введите минимум два параметра перед отправкой.");
        return;
      }

      // chat_id: сначала из chat_id, если нет — берём user_id
      const chatId =
        tgContext.chat_id && tgContext.chat_id !== "None"
          ? Number(tgContext.chat_id)
          : tgContext.user_id && tgContext.user_id !== "None"
          ? Number(tgContext.user_id)
          : null;

      const messageId =
        tgContext.message_id && tgContext.message_id !== "None"
          ? Number(tgContext.message_id)
          : null;

      const userId =
        tgContext.user_id && tgContext.user_id !== "None"
          ? Number(tgContext.user_id)
          : null;

      const result = {
        distanceKm: s.D ?? null,
        time: (() => {
          if (!s.hasT) return null;
          const t = s.Tsec;
          const hh = Math.floor(t / 3600);
          const mm = Math.floor((t % 3600) / 60);
          const ss = t % 60;
          return {
            hours: hh,
            minutes: mm,
            seconds: ss,
            totalSeconds: t,
          };
        })(),
        pace100m: s.hasP100
          ? {
              minutes: Math.floor(s.P100 / 60),
              seconds: s.P100 % 60,
              totalSeconds: s.P100,
            }
          : null,
        pacePerKm: s.hasPKM
          ? {
              minutes: Math.floor(s.PKM / 60),
              seconds: s.PKM % 60,
              totalSeconds: s.PKM,
            }
          : null,
        speedKmh: s.V ?? null,
        timestamp: new Date().toISOString(),
        chat_id: chatId,
        message_id: messageId,
        user_id: userId,
      };

      console.log("Отправка результата на backend:", result);

      try {
        const resp = await fetch(BACKEND_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(result),
        });

        const data = await resp.json().catch(() => ({}));
        console.log("Ответ backend:", data);

        if (!resp.ok || data.status !== "ok") {
          throw new Error("Backend error: " + JSON.stringify(data));
        }

        // В Telegram — закрываем WebView, в обычном браузере показываем alert
        if (
          window.TelegramGameProxy ||
          (window.Telegram && Telegram.WebApp)
        ) {
          closeGameWebView();
        } else {
          alert("Результат отправлен в чат ✅");
        }
      } catch (e) {
        console.error("Ошибка отправки на backend:", e);
        alert("Не удалось отправить результат. Попробуйте ещё раз позже.");
      }
    });

    compute();
  </script>
</body>
</html>
